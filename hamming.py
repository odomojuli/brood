from itertools import tee
"""
The "tee" function does just what we want. It internally keeps a generated
result for as long as it has not been "consumed" from all of the duplicated
iterators, whereupon it is deleted. You can therefore print the hamming
sequence during hours without increasing memory usage, or very little.

The beauty of it is that recursive running-after-their-tail FP algorithms
are quite straightforwardly expressed with this Python idiom.
"""

"""
From Djikstra:
    1. The sequence of Hamming numbers begins with the number 1.
    2. The remaining values in the sequence are of the form 2h, 3h, and 5h, where h is any Hamming number.
    3. Therefore, the sequence H may be generated by outputting the value 1, and then merging the sequences 2H, 3H and 5H.

Hamming numbers are numbers of the form
    H = 2^i x 3^j x 5^k
    Where i, j, k â‰¥ 0

The sequence of Hamming numbers:
    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, ...]
        is the set of all numbers of form 2^i * 3^j * 5^k,
        where i, j and k are non-negative integers.
"""

"""
Naive method:
def is_hamming_numbers(x):
	if x == 1:
		return 1
	if x % 2 == 0:
		return is_hamming_numbers(x/2)
	if x % 3 == 0:
		return is_hamming_numbers(x/3)
	if x % 5 == 0:
		return is_hamming_numbers(x/5)
	return 0

def hamming_numbers_sequence(x):
	if x == 1:
		return 1
	hamming_numbers_sequence(x-1)
	if is_hamming_numbers(x) == True:
		print("%s" % x, end=' ')
"""

"""
Rather than iterate the value from a list,
a generator is appropriate since we only iterate once.
"""
def firstn(g,n):
    return [next(g) for i in range(n)]

def times(n,g):
    for i in g:
        yield n * i

def merge(g,h):
    ng = next(g)
    nh = next(h)
    while 1:
        if ng < nh:
            yield ng
            ng = next(g)
        elif ng > nh:
            yield nh
            nh = next(h)
        else:
            yield ng
            ng = next(g)
            nh = next(h)

def m235():
    def _m235():
        # Generate first value
        yield 1
        for n in merge(times(2,m2),
                    merge(times(3,m3),
                        times(5,m5))):
            yield n
    m1 = _m235()
    m2, m3, m5, mRes = tee(m1,4)
    return mRes

it = m235()


# Multiply output by number of lines in range(n):
"""
for i in range(12):
    print (firstn(it,5))
"""
# Generate table
import pandas as pd
import numpy as np
generator = (firstn(it, 5) for i in range(61))
df = pd.DataFrame(generator)
print (df)

np.savetxt(r'smooth.txt', df.values, fmt='%d')
df.to_csv(r'smooth.csv', header=True, index=True, sep=';')